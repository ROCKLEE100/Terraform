# .github/workflows/terraform-deploy.yml
# GitHub Actions workflow for Terraform deployment

name: Terraform GCP Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'modules/**'
      - 'root/**'
      - '.github/workflows/terraform-deploy.yml'
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  TF_VERSION: '1.6.0'
  GCP_REGION: 'us-central1'
  WORKING_DIR: './root'

jobs:
  terraform:
    name: 'Terraform Plan & Apply'
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      id-token: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Create terraform.tfvars
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          cat > terraform.tfvars <<EOF
          project_id          = "${{ secrets.GCP_PROJECT_ID }}"
          region              = "${{ env.GCP_REGION }}"
          zone                = "${{ env.GCP_REGION }}-a"
          project_prefix      = "assignment"
          environment         = "assignment"
          public_subnet_cidr  = "10.0.1.0/24"
          private_subnet_cidr = "10.0.2.0/24"
          machine_type        = "e2-micro"
          vm_image            = "debian-cloud/debian-11"
          boot_disk_size      = 20
          boot_disk_type      = "pd-standard"
          ssh_username        = "gcpuser"
          EOF

      - name: Update backend configuration
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          sed -i 's/YOUR_BUCKET_NAME/${{ secrets.GCS_BACKEND_BUCKET }}/g' provider.tf

      - name: Terraform Format Check
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init

      - name: Terraform Validate
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          terraform plan -no-color -out=tfplan
          terraform show -no-color tfplan > plan_output.txt
        continue-on-error: true

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('${{ env.WORKING_DIR }}/plan_output.txt', 'utf8');
            const output = `#### Terraform Plan ðŸ“–
            
            <details><summary>Show Plan</summary>
            
            \`\`\`terraform
            ${plan.substring(0, 65000)}
            \`\`\`
            
            </details>
            
            **Working Directory**: \`${{ env.WORKING_DIR }}\``;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform apply -auto-approve tfplan

      - name: Terraform Output
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        id: output
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          echo "NGINX_URL=$(terraform output -raw nginx_url)" >> $GITHUB_OUTPUT
          echo "PUBLIC_IP=$(terraform output -raw public_vm_external_ip)" >> $GITHUB_OUTPUT
          echo "PUBLIC_VM=$(terraform output -raw public_vm_name)" >> $GITHUB_OUTPUT
          echo "PRIVATE_VM=$(terraform output -raw private_vm_name)" >> $GITHUB_OUTPUT
          terraform output

      - name: Create deployment summary
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ðŸš€ Deployment Successful!
          
          ### ðŸ“Š Infrastructure Created
          
          #### ðŸŒ Networking
          - **VPC**: Custom VPC with public and private subnets
          - **Public Subnet**: 10.0.1.0/24
          - **Private Subnet**: 10.0.2.0/24
          - **Cloud NAT**: Configured for private subnet
          
          #### ðŸ’» Virtual Machines
          
          **Public VM** (Internet-Facing)
          - **Name**: ${{ steps.output.outputs.PUBLIC_VM }}
          - **External IP**: ${{ steps.output.outputs.PUBLIC_IP }}
          - **NGINX URL**: [${{ steps.output.outputs.NGINX_URL }}](${{ steps.output.outputs.NGINX_URL }})
          - **Access**: Direct from internet via HTTP
          
          **Private VM** (Internal Only)
          - **Name**: ${{ steps.output.outputs.PRIVATE_VM }}
          - **External IP**: None (isolated)
          - **Access**: Via IAP tunnel only
          
          ### ðŸ”— Quick Access
          
          1. **Access NGINX Web Server**:
             \`\`\`
             ${{ steps.output.outputs.NGINX_URL }}
             \`\`\`
          
          2. **SSH to Public VM**:
             \`\`\`bash
             gcloud compute ssh ${{ steps.output.outputs.PUBLIC_VM }} --zone=us-central1-a --project=${{ secrets.GCP_PROJECT_ID }}
             \`\`\`
          
          3. **SSH to Private VM** (requires IAP):
             \`\`\`bash
             gcloud compute ssh ${{ steps.output.outputs.PRIVATE_VM }} --zone=us-central1-a --project=${{ secrets.GCP_PROJECT_ID }} --tunnel-through-iap
             \`\`\`
          
          ### ðŸ“ Architecture
          
          \`\`\`
          Internet â†’ Public VM (NGINX) â†â†’ Private VM
                     (10.0.1.x)              (10.0.2.x)
                     [External IP]           [No External IP]
                                              â†“
                                          Cloud NAT
          \`\`\`
          
          ### ðŸ” Security
          - SSH keys stored in Secret Manager
          - Private VM has no external IP
          - IAP tunneling for secure SSH access
          - Cloud NAT for private subnet internet (outbound only)
          
          ---
          
          **Deployed at**: $(date)
          EOF

  destroy:
    name: 'Terraform Destroy (Manual)'
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    environment: 
      name: destroy-approval
    
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Create terraform.tfvars
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          cat > terraform.tfvars <<EOF
          project_id = "${{ secrets.GCP_PROJECT_ID }}"
          region     = "${{ env.GCP_REGION }}"
          EOF

      - name: Update backend configuration
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          sed -i 's/YOUR_BUCKET_NAME/${{ secrets.GCS_BACKEND_BUCKET }}/g' provider.tf

      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init

      - name: Terraform Destroy
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform destroy -auto-approve